document.addEventListener("DOMContentLoaded", function () { const savedProgress = JSON.parse(localStorage.getItem("quizProgress")); const genderSelectorWrap = document.querySelector(".form_step_wrap.gender_selector"); const maleWrap = document.querySelector(".form_step_wrap.male"); const femaleWrap = document.querySelector(".form_step_wrap.female"); const contactWrap = document.querySelector(".form_step_wrap.contact"); let currentStep = 0; let isTransitioning = false; let steps = []; let selectedPath = null; let timer = null; let currentBodyType = null; let historyStack = []; document.querySelector(".nav_logo")?.addEventListener("click", function (e) { e.preventDefault(); localStorage.removeItem("quizProgress"); historyStack = []; selectedPath = null; currentBodyType = null; toggleFormWrapVisibility(genderSelectorWrap); steps = Array.from(genderSelectorWrap.querySelectorAll(".form_step")); currentStep = 0; showStep(0, false); }); const prevButtons = document.querySelectorAll(".quiz_nav_prev"); if (savedProgress) { selectedPath = savedProgress.selectedPath; currentBodyType = savedProgress.currentBodyType; if (selectedPath === "male") { toggleFormWrapVisibility(maleWrap); steps = Array.from(maleWrap.querySelectorAll(".form_step")); } else if (selectedPath === "female") { toggleFormWrapVisibility(femaleWrap); steps = Array.from(femaleWrap.querySelectorAll(".form_step")); } else { toggleFormWrapVisibility(genderSelectorWrap); steps = Array.from(genderSelectorWrap.querySelectorAll(".form_step")); } if (currentBodyType) { const wrapper = selectedPath === "male" ? maleWrap : femaleWrap; const branchWrap = wrapper.querySelector(`.body_type.${currentBodyType}`); if (branchWrap) { steps = Array.from(branchWrap.querySelectorAll(".form_step")); } } currentStep = savedProgress.currentStep || 0; showStep(currentStep, false); } else { toggleFormWrapVisibility(genderSelectorWrap); steps = Array.from(genderSelectorWrap.querySelectorAll(".form_step")); showStep(0); } function saveState() { const state = { selectedPath, currentBodyType, currentStep, stepsSelector: steps.map(step => step.id || step.getAttribute("data-step-id")), inputs: Array.from(document.querySelectorAll("input, select, textarea")).map(el => ({ selector: getUniqueSelector(el), value: el.type === "checkbox" || el.type === "radio" ? el.checked : el.value })) }; historyStack.push(state); } function isRadioOnlyStep(step) { if (!step) return false; const hasNextBtn = !!step.querySelector('.quiz_btn'); const radios = step.querySelectorAll('input[type="radio"]'); const checkboxes = step.querySelectorAll('input[type="checkbox"]'); return !hasNextBtn && radios.length > 0 && checkboxes.length === 0; } function restoreState(state) { if (!state) return; selectedPath = state.selectedPath; currentBodyType = state.currentBodyType; if (selectedPath === "male") { toggleFormWrapVisibility(maleWrap); steps = Array.from(maleWrap.querySelectorAll(".form_step")); } else if (selectedPath === "female") { toggleFormWrapVisibility(femaleWrap); steps = Array.from(femaleWrap.querySelectorAll(".form_step")); } else { toggleFormWrapVisibility(genderSelectorWrap); steps = Array.from(genderSelectorWrap.querySelectorAll(".form_step")); } if (currentBodyType) { const wrapper = selectedPath === "male" ? maleWrap : femaleWrap; const branchWrap = wrapper.querySelector(`.body_type.${currentBodyType}`); if (branchWrap) { steps = Array.from(branchWrap.querySelectorAll('.form_step')); } } currentStep = state.currentStep || 0; showStep(currentStep, false); const active = steps[currentStep]; const activeIsRadioOnly = isRadioOnlyStep(active); const SLIDER_IDS = ['maleweightSlider','malegoalWeightSlider','weightSlider','goalWeightSlider']; const restoredEls = []; (state.inputs || []).forEach(inputData => { const el = document.querySelector(inputData.selector); if (!el) return; const isSliderControl = (el.tagName.toUpperCase() === 'INPUT' && (el.classList.contains('slider') || el.type === 'range')) || (el.id && SLIDER_IDS.includes(el.id)); if (activeIsRadioOnly && active && active.contains(el) && el.type === 'radio') { return; } if (isSliderControl) { if (typeof inputData.value !== 'undefined' && String(el.value) !== String(inputData.value)) { el.value = inputData.value; el.dispatchEvent(new Event("input", { bubbles: true })); } restoredEls.push(el); return; } if (el.type === "checkbox" || el.type === "radio") { el.checked = !!inputData.value; try { el.defaultChecked = !!inputData.value; } catch (e) {} } else { el.value = inputData.value; } restoredEls.push(el); }); syncInputVisuals(); if (activeIsRadioOnly && active) { requestAnimationFrame(() => { requestAnimationFrame(() => { const radios = Array.from(active.querySelectorAll('input[type="radio"]')); radios.forEach(r => { r.checked = false; try { r.defaultChecked = false; } catch (e) {} r.dispatchEvent(new Event('change', { bubbles: true })); }); syncInputVisuals(); const parentWrap = active.closest('.form_step_wrap'); if (parentWrap) parentWrap.style.height = active.offsetHeight + 'px'; }); }); } restoredEls.forEach(el => { if (activeIsRadioOnly && active && active.contains(el) && el.type === 'radio') return; try { el.dispatchEvent(new Event("input", { bubbles: true })); } catch(e){} try { el.dispatchEvent(new Event("change", { bubbles: true })); } catch(e){} }); if (!activeIsRadioOnly && active) { const parentWrap = active.closest('.form_step_wrap'); if (parentWrap) parentWrap.style.height = active.offsetHeight + 'px'; } } function getUniqueSelector(el) { if (el.id) return `#${el.id}`; if (el.name) return `[name="${el.name}"]`; return el.tagName.toLowerCase() + (el.className ? '.' + el.className.trim().replace(/\s+/g, '.') : ''); } function setStepFlow(path) { saveState(); selectedPath = path; if (path === "male") { toggleFormWrapVisibility(maleWrap); steps = Array.from(maleWrap.querySelectorAll(".form_step")); } else if (path === "female") { toggleFormWrapVisibility(femaleWrap); steps = Array.from(femaleWrap.querySelectorAll(".form_step")); } currentStep = 0; showStep(currentStep); } function toggleFormWrapVisibility(activeWrap) { [genderSelectorWrap, maleWrap, femaleWrap, contactWrap].forEach(wrap => { if (wrap === activeWrap) { wrap.style.display = "block"; } else { wrap.style.display = "none"; wrap.style.height = "0px"; } }); } function updateProgressBar() { const totalSteps = steps.length; const progress = ((currentStep + 1) / totalSteps) * 100; const progressFill = document.querySelector(".progress_bar"); if (progressFill) { progressFill.style.width = progress + "%"; } } function showStep(index, saveHistory = true) { if (isTransitioning) return; isTransitioning = true; if (saveHistory) saveState(); localStorage.setItem("quizProgress", JSON.stringify({ selectedPath, currentBodyType, currentStep: index })); clearTimeout(timer); removeAllEventListeners(); const currentActive = document.querySelector(".form_step.active"); if (currentActive && steps[index] !== currentActive) { setTimeout(() => { currentActive.classList.add("exiting"); currentActive.classList.remove("active"); setTimeout(() => { currentActive.classList.remove("exiting"); activateNewStep(index); isTransitioning = false; }, 400); }, 200); } else { activateNewStep(index); isTransitioning = false; } } function activateNewStep(index) { document.querySelectorAll(".form_step").forEach(step => { step.classList.remove("active", "exiting"); }); if (steps[index]) { steps[index].classList.add("active"); currentStep = index; handleStepBehavior(steps[currentStep]); updateProgressBar(); const parentWrap = steps[index].closest('.form_step_wrap'); if (parentWrap) { parentWrap.style.height = steps[index].offsetHeight + 'px'; } if (steps[index].hasAttribute("confetti")) { launchConfetti?.(); } } } function getNumericValue(el) { if (!el) return NaN; const rawValue = String(el.value); const cleaned = rawValue.replace(/[^\d.]/g, ""); return parseFloat(cleaned); } function updateWeightRecommendation(gender) { let currentSlider, goalSlider; if (gender === "male") { currentSlider = document.getElementById('maleweightSlider'); goalSlider = document.getElementById('malegoalWeightSlider'); } else if (gender === "female") { currentSlider = document.getElementById('weightSlider'); goalSlider = document.getElementById('goalWeightSlider'); } const current = getNumericValue(currentSlider); const goal = getNumericValue(goalSlider); if (isNaN(current) || isNaN(goal) || current <= 0) return; const wantsToGain = goal > current; const lossPercent = ((current - goal) / current) * 100; let recommendation = null; if (wantsToGain) { recommendation = 'skinny'; } else if (lossPercent >= 10) { recommendation = 'overweight'; } else if (lossPercent >= 1) { recommendation = 'soft'; } document.querySelectorAll(`.form_step[body-goal="${gender}"]`).forEach(step => { step.querySelectorAll('.goal_choice_option').forEach(opt => { opt.classList.remove('is--recommended'); const recText = opt.querySelector('.recommended_text'); if (recText) { recText.style.display = "none"; } }); if (recommendation) { const label = step.querySelector(`.goal_choice_option[recommendation="${recommendation}"]`); const recText = label?.querySelector('.recommended_text'); if (recText) { recText.style.display = "block"; } } }); } document.getElementById('maleweightSlider')?.addEventListener('input', () => updateWeightRecommendation('male')); document.getElementById('malegoalWeightSlider')?.addEventListener('input', () => updateWeightRecommendation('male')); document.getElementById('weightSlider')?.addEventListener('input', () => updateWeightRecommendation('female')); document.getElementById('goalWeightSlider')?.addEventListener('input', () => updateWeightRecommendation('female')); updateWeightRecommendation('male'); updateWeightRecommendation('female'); function handleStepBehavior(step) { const nextBtn = step.querySelector(".quiz_btn"); const hasBtn = !!nextBtn; if (step.id === "select-gender") { const genderRadios = step.querySelectorAll('input[gender-path]'); genderRadios.forEach(radio => { radio.addEventListener("click", function () { if (radio.checked) { const path = radio.getAttribute("gender-path"); if (path === "male" || path === "female") { selectedPath = path; setStepFlow(selectedPath); } } }); radio.setAttribute("data-listening", "true"); }); } else if (step.getAttribute("option-choice") === "true") { const nextHandler = () => { const selected = step.querySelector('input[data-option]:checked'); if (selected && !isTransitioning) { nextBtn.removeEventListener("click", nextHandler); const selectedOption = selected.getAttribute("data-option"); const currentWrap = selectedPath === "male" ? maleWrap : femaleWrap; let newSteps = Array.from(currentWrap.querySelectorAll('.form_step')); if (currentBodyType) { const bodyTypeWrap = currentWrap.querySelector(`.body_type.${currentBodyType}`); if (bodyTypeWrap) { newSteps = Array.from(bodyTypeWrap.querySelectorAll('.form_step')); } } newSteps = newSteps.filter(s => { const revealAttr = s.getAttribute("option-reveal"); return !revealAttr || revealAttr === selectedOption; }); steps = newSteps; currentStep = steps.indexOf(step) + 1; showStep(currentStep); } }; if (nextBtn) { nextBtn.addEventListener("click", nextHandler); nextBtn.setAttribute("data-listening", "true"); } } else if (step.getAttribute("body-goal")) { updateWeightRecommendation(); const gender = step.getAttribute("body-goal"); const nextHandler = () => { const selected = step.querySelector('input[body-type]:checked'); if (selected && !isTransitioning) { saveState(); nextBtn.removeEventListener("click", nextHandler); currentBodyType = selected.getAttribute("body-type"); const wrapper = gender === "male" ? maleWrap : femaleWrap; const branchWrap = wrapper.querySelector(`.body_type.${currentBodyType}`); if (branchWrap) { steps = Array.from(branchWrap.querySelectorAll('.form_step')); currentStep = 0; showStep(currentStep); } } }; if (nextBtn) { nextBtn.addEventListener("click", nextHandler); nextBtn.setAttribute("data-listening", "true"); } } else if (!hasBtn) { const radios = step.querySelectorAll("input[type='radio'], input[type='checkbox']"); radios.forEach(radio => { radio.addEventListener("change", () => { if (radio.checked && !isTransitioning) { goToNextStep(); } }); radio.setAttribute("data-listening", "true"); }); } else if (hasBtn) { const radios = step.querySelectorAll("input[type='radio'], input[type='checkbox']"); const handler = () => { const anySelected = Array.from(radios).some(input => input.checked); if (anySelected && !isTransitioning) { nextBtn.removeEventListener("click", handler); goToNextStep(); } }; if (radios.length > 0) { nextBtn.addEventListener("click", handler); nextBtn.setAttribute("data-listening", "true"); } else { const fallbackHandler = () => { if (!isTransitioning) { nextBtn.removeEventListener("click", fallbackHandler); goToNextStep(); } }; nextBtn.addEventListener("click", fallbackHandler); nextBtn.setAttribute("data-listening", "true"); } } if (!hasBtn && !step.querySelector("input[type='radio'], input[type='checkbox']") && step.id !== "select-gender" && step.getAttribute("option-choice") !== "true" && !step.getAttribute("body-goal")) { const delay = parseInt(step.getAttribute("data-delay")) || 2500; timer = setTimeout(() => { if (!isTransitioning) goToNextStep(); }, delay); } } function syncInputVisuals() { document.querySelectorAll('.frustrations_option, .goal_choice_option, .workout_option').forEach(option => { option.style.backgroundColor = ''; option.style.color = ''; }); document.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => { const parentOption = input.closest('.frustrations_option') || input.closest('.goal_choice_option') || input.closest('.workout_option'); if (parentOption) { if (input.checked) { parentOption.style.backgroundColor = 'black'; parentOption.style.color = 'white'; } else { } } const label = input.closest('label'); if (label) { const knob = label.querySelector('.faux_radio_btn_knob'); if (knob) knob.style.backgroundColor = input.checked ? '#ad1a1a' : ''; } }); } document.removeEventListener?.('change', window.__sync_input_visuals_change_handler__); window.__sync_input_visuals_change_handler__ = function (ev) { const t = ev.target; if (!t || !(t.matches && (t.matches('input[type="radio"]') || t.matches('input[type="checkbox"]')))) return; syncInputVisuals(); }; document.addEventListener('change', window.__sync_input_visuals_change_handler__, { capture: false }); function removeAllEventListeners() { const SLIDER_IDS = new Set([ 'maleweightSlider', 'malegoalWeightSlider', 'weightSlider', 'goalWeightSlider' ]); document.querySelectorAll("[data-listening='true']").forEach(el => { const tag = el.tagName.toUpperCase(); const isSliderControl = (tag === 'INPUT' && (el.classList.contains('slider') || el.type === 'range')) || (el.id && SLIDER_IDS.has(el.id)); if (isSliderControl) { el.removeAttribute('data-listening'); return; } const state = {}; if (tag === 'INPUT') { state.type = el.type; state.checked = el.checked; state.value = el.value; } else if (tag === 'TEXTAREA') { state.value = el.value; } else if (tag === 'SELECT') { state.selectedIndex = el.selectedIndex; state.selectedOptions = Array.from(el.options).map(o => o.selected); } const clone = el.cloneNode(true); if (tag === 'INPUT') { if (clone.type === 'checkbox' || clone.type === 'radio') { try { clone.checked = !!state.checked; } catch (e) {} } if (typeof state.value !== 'undefined') clone.value = state.value; } else if (tag === 'TEXTAREA') { clone.value = state.value; } else if (tag === 'SELECT') { if (typeof state.selectedIndex !== 'undefined') clone.selectedIndex = state.selectedIndex; if (Array.isArray(state.selectedOptions)) { Array.from(clone.options).forEach((opt, i) => { opt.selected = !!state.selectedOptions[i]; }); } } if (el.parentNode) { el.parentNode.replaceChild(clone, el); } }); syncInputVisuals(); } function goToNextStep() { if (isTransitioning) return; const isLast = currentStep >= steps.length - 1; if (!isLast) { showStep(currentStep + 1); return; } const active = steps[currentStep]; const inBodyTypeBranch = !!currentBodyType; const hasContactBtn = !!(active && active.querySelector(".contact_nav_btn")); const explicitlyAuto = active && active.getAttribute("data-auto-contact") === "true"; if (inBodyTypeBranch && (explicitlyAuto || !hasContactBtn)) { try { saveState(); } catch (e) {} clearTimeout(timer); toggleFormWrapVisibility(contactWrap); steps = Array.from(contactWrap.querySelectorAll(".form_step")); currentStep = 0; showStep(currentStep, false); return; } } function goToPrevStep() { if (historyStack.length > 0) { const prevState = historyStack.pop(); restoreState(prevState); } else { selectedPath = null; currentBodyType = null; toggleFormWrapVisibility(genderSelectorWrap); steps = Array.from(genderSelectorWrap.querySelectorAll(".form_step")); currentStep = 0; showStep(currentStep, false); } } prevButtons.forEach(btn => { btn.addEventListener("click", function () { if (!isTransitioning) goToPrevStep(); }); }); document.querySelectorAll(".contact_nav_btn").forEach(btn => { btn.addEventListener("click", function () { toggleFormWrapVisibility(contactWrap); steps = Array.from(contactWrap.querySelectorAll(".form_step")); currentStep = 0; showStep(currentStep); }); }); }); (function() { const formSteps = document.querySelectorAll('.form_step'); if (!formSteps.length) return; function preventHorizontalScroll(event) { if (event.type === 'wheel') { if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) { event.preventDefault(); } } else if (event.type === 'touchmove') { const touch = event.touches[0] || event.changedTouches[0]; const startX = parseFloat(event.target.getAttribute('data-touch-start-x')); const deltaX = touch.clientX - startX; if (Math.abs(deltaX) > 10) { event.preventDefault(); } } } function handleTouchStart(event) { const touch = event.touches[0]; event.target.setAttribute('data-touch-start-x', touch.clientX); } formSteps.forEach(step => { step.style.overflowX = 'hidden'; step.addEventListener('wheel', preventHorizontalScroll, { passive: false }); step.addEventListener('touchstart', handleTouchStart, { passive: true }); step.addEventListener('touchmove', preventHorizontalScroll, { passive: false }); step.addEventListener('scroll', function() { if (this.scrollLeft !== 0) { this.scrollLeft = 0; } }); }); const style = document.createElement('style'); style.textContent = ` .form_step { overflow-x: hidden !important; overscroll-behavior-x: contain !important; } `; document.head.appendChild(style); })(); document.querySelectorAll('.slider').forEach(slider => { slider.addEventListener('touchstart', (e) => { document.activeElement?.blur(); setTimeout(() => { e.target.focus(); }, 0); e.stopPropagation(); }, { passive: true }); slider.addEventListener('pointerdown', (e) => { document.activeElement?.blur(); setTimeout(() => { e.target.focus(); }, 0); e.stopPropagation(); }); }); document.addEventListener('pointerdown', (e) => { const active = document.activeElement; if (active && active.classList.contains('slider') && !e.target.classList.contains('slider')) { active.blur(); } }); document.addEventListener('touchstart', (e) => { const active = document.activeElement; if (active && active.classList.contains('slider') && !e.target.classList.contains('slider')) { active.blur(); } }, { passive: true }); (function() { function getColorForPercentage(pct) { if (pct <= 40) { return "#a20000"; } else if (pct > 40 && pct <= 65) { const ratio = (pct - 40) / (65 - 40); const r = 162 + (255 - 162) * ratio; const g = 0 + (255 - 0) * ratio; return `rgb(${Math.round(r)}, ${Math.round(g)}, 0)`; } else { const ratio = (pct - 65) / (100 - 65); const r = 255 - (255 * ratio); const g = 255 - (255 - 128) * ratio; return `rgb(${Math.round(r)}, ${Math.round(g)}, 0)`; } } function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); } const activeAnimations = new Map(); const resetTimers = new Map(); function showPopupForBar(bar, start, target) { const diff = Math.round(target - start); if (diff === 0) return; if (!bar.hasAttribute('data-bar-start')) return; const parent = bar.parentElement || document.body; const computedPos = window.getComputedStyle(parent).position; if (computedPos === 'static') { parent.dataset._bar_set_rel = 'true'; parent.style.position = 'relative'; } const popup = document.createElement('div'); popup.className = 'popup-text'; popup.textContent = (diff > 0 ? '+' : '') + diff + '%'; parent.appendChild(popup); popup.style.animation = 'popup-pop 1.6s cubic-bezier(.22,1,.36,1) forwards'; setTimeout(() => { popup.remove(); if (parent.dataset._bar_set_rel === 'true') { delete parent.dataset._bar_set_rel; parent.style.position = ''; } }, 1800); } function animateProgressBar(bar) { if (activeAnimations.has(bar)) { activeAnimations.get(bar).cancel(); activeAnimations.delete(bar); } if (resetTimers.has(bar)) { clearTimeout(resetTimers.get(bar)); resetTimers.delete(bar); } const fill = bar.querySelector(".progress-fill"); const text = bar.querySelector(".progress-text"); const target = parseFloat(bar.getAttribute("data-bar-fill")) || 0; const hasStart = bar.hasAttribute("data-bar-start"); const rawStart = hasStart ? parseFloat(bar.getAttribute("data-bar-start")) : 0; const s = Math.max(0, Math.min(100, rawStart)); const t = Math.max(0, Math.min(100, target)); const durationAttr = bar.getAttribute('data-duration') || bar.getAttribute('data-speed'); const duration = durationAttr ? Math.max(150, parseFloat(durationAttr) * 1000 || parseFloat(durationAttr) || 2000) : 2000; fill.style.width = s + "%"; fill.style.backgroundColor = getColorForPercentage(s); if (text) text.textContent = Math.round(s) + "%"; const startTime = performance.now(); let rafId = null; let cancelled = false; function step(now) { if (cancelled) return; const elapsed = now - startTime; const rawProgress = Math.min(elapsed / duration, 1); const eased = easeOutCubic(rawProgress); const current = s + (t - s) * eased; fill.style.width = current + "%"; fill.style.backgroundColor = getColorForPercentage(current); if (text) text.textContent = Math.round(current) + "%"; if (rawProgress < 1) { rafId = requestAnimationFrame(step); } else { activeAnimations.delete(bar); } } rafId = requestAnimationFrame(step); activeAnimations.set(bar, { cancel() { cancelled = true; if (rafId) cancelAnimationFrame(rafId); } }); if (hasStart) showPopupForBar(bar, s, t); } function resetProgressBar(bar) { if (activeAnimations.has(bar)) { activeAnimations.get(bar).cancel(); activeAnimations.delete(bar); } if (resetTimers.has(bar)) { clearTimeout(resetTimers.get(bar)); resetTimers.delete(bar); } const timeout = setTimeout(() => { const fill = bar.querySelector(".progress-fill"); const text = bar.querySelector(".progress-text"); if (fill) { fill.style.width = "0%"; fill.style.backgroundColor = getColorForPercentage(0); } if (text) text.textContent = "0%"; resetTimers.delete(bar); }, 300); resetTimers.set(bar, timeout); } function monitorFormSteps() { let lastActive = null; const observer = new MutationObserver(() => { const activeStep = document.querySelector(".form_step.active"); if (lastActive && lastActive !== activeStep) { const bars = lastActive.querySelectorAll(".progress-bar"); bars.forEach(bar => resetProgressBar(bar)); } if (activeStep && activeStep !== lastActive) { lastActive = activeStep; const bars = activeStep.querySelectorAll(".progress-bar"); bars.forEach(bar => animateProgressBar(bar)); } }); observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ["class"] }); const activeStep = document.querySelector(".form_step.active"); if (activeStep) { const bars = activeStep.querySelectorAll(".progress-bar"); bars.forEach(bar => animateProgressBar(bar)); } } monitorFormSteps(); })(); function createWavePath(width, amplitude, offsetY, phase, frequency = 2.5) { const points = []; for (let x = 0; x <= width; x++) { const y = amplitude * Math.sin((x / width) * frequency * 2 * Math.PI + phase) + offsetY; points.push([x, y]); } let d = `M ${points[0][0]} ${points[0][1]}`; for (let i = 1; i < points.length; i++) { d += ` L ${points[i][0]} ${points[i][1]}`; } d += ` L ${width} 200 L 0 200 Z`; return d; } const activeGSAPAnimations = new Map(); const resetTimeouts = new Map(); function animateLiquidById(id, targetPercent) { const container = document.getElementById(id); if (!container) return; if (activeGSAPAnimations.has(id)) { activeGSAPAnimations.get(id)(); activeGSAPAnimations.delete(id); } const hasStart = container.hasAttribute('data-start'); const startPercent = hasStart ? parseInt(container.getAttribute('data-start')) || 0 : 0; const waves = [ { el: container.querySelector('.wave1'), amp: 8, phase: 0, speed: 0.02 }, { el: container.querySelector('.wave2'), amp: 6, phase: 0, speed: 0.015 }, { el: container.querySelector('.wave3'), amp: 4, phase: 0, speed: 0.01 }, { el: container.querySelector('.wave4'), amp: 2, phase: 0, speed: 0.007 } ]; const text = container.querySelector(".percent-text"); const width = 200; const height = 200; const startOffsetY = height - (startPercent / 100) * height; const targetOffsetY = height - (targetPercent / 100) * height; const data = { percent: startPercent, offsetY: startOffsetY }; const speed = parseFloat(container.getAttribute('data-speed')) || 2; const tween = gsap.to(data, { percent: targetPercent, offsetY: targetOffsetY, duration: speed, ease: "power3.out", onUpdate() { const currentPercent = Math.round(data.percent); text.textContent = `${currentPercent}%`; text.setAttribute("fill", "black"); } }); const tick = () => { waves.forEach(wave => { wave.phase += wave.speed; wave.el.setAttribute("d", createWavePath(width, wave.amp, data.offsetY, wave.phase)); }); }; gsap.ticker.add(tick); const stop = () => { tween.kill(); gsap.ticker.remove(tick); text.textContent = "0%"; }; activeGSAPAnimations.set(id, stop); if (hasStart) { showPopup(container, startPercent, targetPercent); } } function showPopup(container, start, end) { const diff = end - start; if (diff === 0) return; const popup = document.createElement("div"); popup.className = "popup-text"; popup.textContent = (diff > 0 ? "+" : "") + diff + "%"; container.appendChild(popup); gsap.fromTo(popup, { x: "110%", y: "0%", opacity: 0, scale: 0.8 }, { x: "130%", y: "-40%", opacity: 1, scale: 1.2, duration: 0.6, ease: "back.out(2)" } ); gsap.to(popup, { y: "-100%", opacity: 0, duration: 1, delay: 1.2, onComplete: () => popup.remove() }); } function monitorLiquidAnimations() { document.querySelectorAll('.form_step').forEach(formStep => { const isActive = formStep.classList.contains('active'); const containers = formStep.querySelectorAll('.liquid-container'); containers.forEach(container => { const id = container.id; const targetFill = parseInt(container.getAttribute('data-fill')) || 0; const wasActive = container.dataset._wasActive === 'true'; if (isActive && !wasActive) { if (resetTimeouts.has(id)) { clearTimeout(resetTimeouts.get(id)); resetTimeouts.delete(id); } animateLiquidById(id, targetFill); container.dataset._wasActive = 'true'; } if (!isActive && wasActive) { container.dataset._wasActive = 'false'; const timeout = setTimeout(() => { if (activeGSAPAnimations.has(id)) { activeGSAPAnimations.get(id)(); activeGSAPAnimations.delete(id); } container.querySelector('.percent-text').textContent = '0%'; }, 300); resetTimeouts.set(id, timeout); } }); }); } setInterval(monitorLiquidAnimations, 200); document.addEventListener("DOMContentLoaded", function () { const radioInputs = document.querySelectorAll('input[type="radio"]'); radioInputs.forEach(radio => { radio.addEventListener('change', () => { document.querySelectorAll('.frustrations_option, .goal_choice_option, .workout_option').forEach(option => { option.style.backgroundColor = '#f4f4f4'; option.style.color = '#333'; }); if (radio.checked) { const parentOption = radio.closest('.frustrations_option') || radio.closest('.goal_choice_option') || radio.closest('.workout_option'); if (parentOption) { parentOption.style.backgroundColor = 'black'; parentOption.style.color = 'white'; } } }); }); }); document.addEventListener("DOMContentLoaded", function () { let bgVideos = document.querySelectorAll("video"); bgVideos.forEach(video => { video.setAttribute("muted", "muted"); video.setAttribute("playsinline", ""); video.setAttribute("autoplay", ""); video.muted = true; video.play().catch(() => { console.log("Safari blocked autoplay. Will require user interaction."); }); }); }); function launchConfetti() { const duration = 2 * 1000; const animationEnd = Date.now() + duration; const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 9999 }; function randomInRange(min, max) { return Math.random() * (max - min) + min; } const interval = setInterval(function() { const timeLeft = animationEnd - Date.now(); if (timeLeft <= 0) { return clearInterval(interval); } const particleCount = 50 * (timeLeft / duration); confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } }); confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } }); }, 250); } document.addEventListener('DOMContentLoaded', () => { const cssEscape = (s) => { if (window.CSS && typeof CSS.escape === 'function') return CSS.escape(s); return String(s).replace(/([^\w-])/g, '\\$1'); }; document.querySelectorAll('label').forEach(label => { const knob = label.querySelector('.faux_radio_btn_knob'); const input = label.querySelector('input[type="radio"], input[type="checkbox"]'); if (!knob || !input) return; knob.style.backgroundColor = input.checked ? '#ad1a1a' : ''; }); document.addEventListener('change', (ev) => { const input = ev.target; if (!input || !(input.matches('input[type="radio"], input[type="checkbox"]'))) return; const parentLabel = input.closest('label'); if (parentLabel) { const knob = parentLabel.querySelector('.faux_radio_btn_knob'); if (knob) knob.style.backgroundColor = input.checked ? '#ad1a1a' : ''; } if (input.type === 'radio' && input.name) { const group = Array.from(document.querySelectorAll(`input[type="radio"][name="${cssEscape(input.name)}"]`)); group.forEach(r => { const pl = r.closest('label'); if (!pl) return; const k = pl.querySelector('.faux_radio_btn_knob'); if (k) k.style.backgroundColor = r.checked ? '#ad1a1a' : ''; }); } }); document.addEventListener('click', (ev) => { const visual = ev.target.closest('.radio_btn'); if (!visual) return; const parentLabel = visual.closest('label'); if (!parentLabel) return; const input = parentLabel.querySelector('input[type="radio"], input[type="checkbox"]'); if (!input) return; ev.preventDefault(); ev.stopPropagation(); input.click(); }); }); document.addEventListener("DOMContentLoaded", () => { document.querySelectorAll(".loading-icon").forEach((svg, index) => { const gradient = svg.querySelector("linearGradient"); if (gradient && gradient.id) { const uniqueId = gradient.id + "_" + index; gradient.id = uniqueId; svg.querySelectorAll("[stroke]").forEach(el => { const stroke = el.getAttribute("stroke"); if (stroke && stroke.includes(`url(#`)) { el.setAttribute("stroke", `url(#${uniqueId})`); } }); } }); }); (function () { function fillLanguageInputFromURL() { const input = document.getElementById('language-type'); if (!input) return; const firstSegment = (location.pathname || '').replace(/^\/+|\/+$/g, '').split('/')[0] || ''; if (/^[a-z]{2}(-[A-Za-z]{2})?$/.test(firstSegment)) { input.value = firstSegment; } else { input.value = ''; } } const avatarMap = { male: { overweight: 'Avatar 1', soft: 'Avatar 3', skinny: 'Avatar 5' }, female: { overweight: 'Avatar 2', soft: 'Avatar 4' } }; function determineAvatarLabel() { try { const saved = JSON.parse(localStorage.getItem('quizProgress') || '{}'); const path = saved.selectedPath || null; const body = saved.currentBodyType || null; if (path && body && avatarMap[path] && avatarMap[path][body]) { return avatarMap[path][body]; } } catch (e) { console.warn('Could not parse quizProgress from localStorage', e); } const genderInput = document.querySelector('input[gender-path]:checked'); const bodyInput = document.querySelector('input[body-type]:checked'); const path = genderInput?.getAttribute('gender-path') || null; const body = bodyInput?.getAttribute('body-type') || null; if (path && body && avatarMap[path] && avatarMap[path][body]) { return avatarMap[path][body]; } const activeBodyTypeNode = document.querySelector('.form_step.active [body-type].selected, .form_step.active input[body-type][checked]'); if (activeBodyTypeNode) { const heuristicBody = activeBodyTypeNode.getAttribute && activeBodyTypeNode.getAttribute('body-type'); const heuristicGender = document.querySelector('.form_step.active input[gender-path]')?.getAttribute('gender-path') || null; if (heuristicGender && heuristicBody && avatarMap[heuristicGender] && avatarMap[heuristicGender][heuristicBody]) { return avatarMap[heuristicGender][heuristicBody]; } } return null; } function clickAvatarIfFound() { if (document.body.dataset._avatarClicked === 'true') return; const label = determineAvatarLabel(); if (!label) { console.warn('No avatar mapping could be determined for current path/body-type.'); return; } const btn = document.querySelector(`[lp-avatar="${label}"]`); if (!btn) { console.warn('No button with lp-avatar="' + label + '" found in DOM.'); return; } document.body.dataset._avatarClicked = 'true'; try { btn.click(); console.log('Simulated click on avatar button:', label); } catch (e) { console.error('Error clicking avatar button:', e); } } function wireSubmitToAvatarClick() { document.addEventListener('click', function (ev) { const s = ev.target.closest && ev.target.closest('.submit_btn'); if (!s) return; setTimeout(clickAvatarIfFound, 50); observeForFormSuccessAndClick(); }, true); document.addEventListener('submit', function (ev) { setTimeout(clickAvatarIfFound, 100); observeForFormSuccessAndClick(); }, true); setTimeout(() => { if (document.querySelector('.w-form-done, .form-success, .submission-success, .thank-you, .success-message')) { clickAvatarIfFound(); } }, 200); } let successObserver = null; function observeForFormSuccessAndClick() { if (successObserver) return; successObserver = new MutationObserver((mutations) => { for (const m of mutations) { for (const n of m.addedNodes) { if (!(n instanceof HTMLElement)) continue; if (n.matches && n.matches('.w-form-done, .form-success, .submission-success, .thank-you, .success-message')) { clickAvatarIfFound(); disconnectObserver(); return; } if (n.querySelector && (n.querySelector('.w-form-done, .form-success, .submission-success, .thank-you, .success-message'))) { clickAvatarIfFound(); disconnectObserver(); return; } } if (m.type === 'attributes' && m.target instanceof HTMLElement) { const t = m.target; if (t.classList && /w-form-done|form-success|submission-success|thank-you|success-message/.test(t.className)) { clickAvatarIfFound(); disconnectObserver(); return; } } } }); successObserver.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] }); setTimeout(disconnectObserver, 12000); } function disconnectObserver() { if (!successObserver) return; try { successObserver.disconnect(); } catch (e) {} successObserver = null; } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { fillLanguageInputFromURL(); wireSubmitToAvatarClick(); }); } else { fillLanguageInputFromURL(); wireSubmitToAvatarClick(); } })();